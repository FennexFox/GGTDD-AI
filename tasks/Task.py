from typing import List, Union, TYPE_CHECKING
from .BaseTask import BaseTask

if TYPE_CHECKING:
    from .Subtask import Subtask
    from .TaskGenerator import TaskGenerator

class Task(BaseTask):
    """
    이름, 선택적 ID, 컨텍스트, 태그, 예상 시간 및 하위 작업이 있는 작업을 나타냅니다.

    Attributes:
        name (str): 작업의 이름.
        id (Optional[Union[int, str]]): 작업의 고유 식별자.
        context (str): 작업에 대한 설명 또는 컨텍스트.
        
        location_tags (List[str]): 작업 위치와 관련된 태그.
        time_tags (List[str]): 작업 시간과 관련된 태그.
        other_tags (List[str]): 기타 관련 태그.
        estimated_minutes (int): 작업 완료 예상 시간(분).

        subtasks (List[Subtask]): 이 작업에 속하는 하위 작업 목록.
    """
    # LLM 생성 여부를 추적하는 프라이빗 필드
    _llm_generated: bool = False

    # 문자열 기반 타입 어노테이션 사용
    subtasks: List['Subtask'] = []
    
    class Config:
        validate_assignment = True
        extra = "forbid"
        
    def __init__(self, **data):
        super().__init__(**data)
        self._llm_generated = data.get("_llm_generated", False)
    
    def require_llm_generation(self) -> None:
        """
        작업이 LLM에 의해 생성되어야 함을 요구합니다.
        """
        if not self._llm_generated:
            raise ValueError(
                "Task must be generated by LLM."
                "Use TaskGenerator.generate_task() to generate a task."
            )
    
    @classmethod
    def create_for_testing(cls, name: str, **kwargs) -> 'Task':
        """
        테스트 목적으로만 사용하는 메서드입니다.
        실제 사용의 경우 TaskGenerator.generate_task()를 사용하세요.
        """
        return cls(name=name, **kwargs)
    
    def set_supertask_of_subtasks(self) -> None:
        """
        이 작업을 모든 하위 작업의 상위 작업으로 설정하고 하위로 전파합니다.
        """
        for subtask in self.subtasks:
            subtask.set_supertask(self, 'task')
            subtask.set_supertask_of_subtasks()
    
    def add_subtask(self, subtask: 'Subtask') -> None:
        """
        새 하위 작업을 이 작업에 추가합니다.

        Args:
            subtask (Subtask): 추가할 하위 작업.
        """
        super().add_subtask(subtask)
        subtask.set_supertask(self, 'task')
    
    def get_all_subtasks(self) -> List['Subtask']:
        """
        중첩된 하위 작업을 포함한 모든 하위 작업의 평면화된 목록을 가져옵니다.

        Returns:
            List[Subtask]: 모든 레벨의 하위 작업.
        """
        all_subtasks: List['Subtask'] = []
        for subtask in self.subtasks:
            all_subtasks.append(subtask)
            all_subtasks.extend(subtask.get_all_subtasks())
        return all_subtasks
    
    def set_supertask(self) -> None:
        """
        모든 하위 작업의 상위 작업을 설정합니다.
        """
        for subtask in self.subtasks:
            subtask.supertask = self
            subtask.set_supertask()
    
    def print_self(self) -> None:
        """
        작업의 세부 정보(하위 작업 포함)를 출력합니다.
        """
        print(f"Task: {self.name}")
        print(f"- Context: {self.context}")
        print(f"- Location Tags: {self.location_tags}")
        print(f"- Time Tags: {self.time_tags}")
        print(f"- Other Tags: {self.other_tags}")
        print(f"- Estimated Minutes: {self.estimated_minutes}")
        print()
        
        print("Subtasks:")
        for subtask in self.subtasks:
            subtask.print_self()
    
    def calculate_total_minutes(self) -> int:
        """
        자신을 수정하지 않고 모든 하위 작업의 총 예상 시간을 계산합니다.

        Returns:
            int: 총 예상 시간(분).
        """
        total_minutes = 0
        for subtask in self.subtasks:
            subtask.update_total_minutes()
            total_minutes += subtask.estimated_minutes
        return total_minutes
    
    def update_total_minutes(self) -> None:
        """
        하위 작업을 기반으로 estimated_minutes를 업데이트합니다.
        """
        self.estimated_minutes = self.calculate_total_minutes()